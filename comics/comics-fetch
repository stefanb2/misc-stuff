#!/usr/bin/perl -w
use 5.030;
use strict;
use warnings;
use open qw(:encoding(UTF-8) :std);

#
# External programs called from this scriot
#
#    convert       (ImageMagick)
#    ebook-convert (calibre)
#
# from perl-TimeDate
use Date::Format;
use File::Spec;
use File::Temp qw(tempdir);
use Getopt::Long;
# from perl-HTML-Tree
use HTML::TreeBuilder;
# requires also LWP::Protocol::https
use LWP::UserAgent;
use MIME::Base64;
use MIME::Lite;
# requires also Authen::SASL
use Net::SMTP;

##############################################################################
#
# Misc. stuff
#
##############################################################################
sub fail($) {
	my($msg) = @_;
	die "$0: ABORT: ${msg}\n";
	# does not return
}

# working directory
my $tempdir;

use constant DEFAULT_FILENAME => "comics.mobi";

##############################################################################
#
# Configuration file
#
##############################################################################
my %config;
sub load_configuration() {
	open(my $fh, '<', "$ENV{HOME}/.comics-fetch.config")
		or die("can't open configuration file: $!");

	while (<$fh>) {
		# remove comments and skip empty lines
		chomp;
		s/\s*#.*$//;
		next if /^\s*$/;

		my($section, $key, $value) = /^\s*(\w+)\.(\w+)\s*=\s*(.+)$/
			or fail("broken config line $.: $_");
		$value =~ s/\s+$//;

		$config{$section}->{$key} = $value;
	}

	close($fh);

	#foreach my $section (sort keys %config) {
	#	foreach my $key (sort keys %{ $config{$section} }) {
	#		my $value = $config{$section}->{$key};
	#		say "${section} ${key} '${value}'";
	#	}
	#}
}

##############################################################################
#
# HTTP handling
#
##############################################################################
{
	my $ua;

	sub http_init() {
		$ua = LWP::UserAgent->new();
		$ua->env_proxy();
		# some pages want us to fake it, so there you go...
		$ua->agent($config{http}->{useragent});
		$ua->default_header('Accept-Encoding' => scalar(HTTP::Message::decodable()));
		#$ua->show_progress(0);
	}

	sub get($;$) {
		my($url, $timeout) = @_;
		my $retries = $config{http}->{retries};
		my $r;

		$ua->timeout($timeout // $config{http}->{timeout});
		while ($retries--) {
			$r = $ua->get($url);
			if ($r->is_success) {
				#print STDERR "HTTP REQUEST: \n", $r->request->as_string, "\n";
				#print STDERR "HTTP RESPONSE: \n", $r->headers_as_string, "\n";
				#print STDERR "LENGTH: ", length($r->content), "\n";
				#print STDERR "HTML: \n", $r->content, "\n";
				my $content = $r->decoded_content;
				#print STDERR "HTML: \n", $content, "\n";
				return(defined($content) ? $content : $r->content);
			}
		}

		print STDERR "HTTP fetch error: ", $r->status_line, "\n";
		return;
	}
}

##############################################################################
#
# Image conversion
#
##############################################################################
sub convert_image($$)
{
	my($base, $content) = @_;
	my $tempfile = "${tempdir}/temp.img";

	# dump URL content as binary data to temporary file for conversion
	if (open(my $fh, '>:raw', $tempfile)) {
		print $fh $content;

		if (close($fh)) {
			# extract image information
			if (open($fh, '-|', 'convert', $tempfile, qw{-identify /dev/null})) {
				my $line = <$fh>;
				close($fh);

				if (my($x, $y) = ($line =~ /\s(\d+)x(\d+)\s/)) {
					# auto-rotation detect
					my @rotate = ($x > $y) ? (-rotate => $config{image}->{rotate}) : ();
					my $basename = "${base}." . $config{image}->{type};

					if (system(
						'convert', $tempfile,
						@rotate,
						'-scale', $config{image}->{scale},
						File::Spec->catfile($tempdir, $basename)
					) == 0) {
						return $basename;
					} else {
						print STDERR "Picture conversion failed: $!\n";
					}
				} else {
					print STDERR "Couldn't extract image dimensions: ${line}";
				}
			} else {
				print STDERR "Couldn't start image identifier: $!\n";
			}
		} else {
			print STDERR "Couldn't save image to file: $!\n";
		}
	} else {
		print STDERR "Couldn't open image file: $!\n";
	}

	return;
}

##############################################################################
#
# HTML generation
#
##############################################################################
{
	my @nodes;

	sub get_nodes() {
		return \@nodes;
	}

	sub create_node() {
		return HTML::Element->new('div');
	}

	sub add_node($) {
		my($node) = @_;
		my $html = $node->as_HTML();
		#print STDERR "HTML: ${html}\n";
		push(@nodes, "${html}\n");
	}

	sub add_image_node($$) {
		my($filename, $extra) = @_;
		my $node = create_node();
		$node->push_content(
			HTML::Element->new('img',
				src => $filename,
				%{$extra}
			)
		);
		add_node($node);
	}

	sub add_error_node($$) {
		my($base, $msg) = @_;
		my $node = create_node();
		$node->push_content(
			HTML::Element->new('p')
				->push_content("${base}: ${msg}")
		);
		add_node($node);
	}
}

##############################################################################
#
# Main program
#
##############################################################################

my %Options = (
	output => DEFAULT_FILENAME,
);

GetOptions(\%Options,
	"mail!",
	"output=s",
) or fail("can't parse command line options");
load_configuration();
http_init();
$tempdir = tempdir(CLEANUP => 1)
	or fail("can't create temorary directory: $!");
print "Temporary directory '${tempdir}'\n";

my $ebook = $Options{output};
if ($Options{mail}) {
	$ebook = File::Spec->catfile($tempdir, $ebook);
}

# That's all folks
exit 0;
